# MVVM 模型？
`MVVM` 是 `Model-View-ViewModel` 的简写,其本质是`MVC`模型的升级版，`Model`代表数据模型，`View`代表看到的页面，`ViewModel`是`View`和`Model`之间的桥梁，数据会绑定到`ViewModel`层并自动将数据渲染到页面中，视图变化的时候会通知`ViewModel`层更新数据。`Vue`的实现方式是对数据(`Model`)进行劫持，当数据变动时，数据会触发劫持时绑定的方法，对`View`进行更新。

----

# Vue.$nextTick()
`nextTick` 是 Vue 提供的一个全局 API，由于 Vue 的异步更新策略，导致数据修改后并不会直接体现在DOM上，此时想要立即获取更新后的DOM状态，需要借助该方法。nextTick的回调是在下次DOM更新循环结束之后执行的延迟回调。<br/>
实现原理：nextTick 使用了宏任务和微任务。根据执行环境分别尝试采用：
- Promise: 可以将函数延迟到当前函数调用栈最末端。
- MutationObserver: 是 H5 新加的一个功能，其功能是监听 DOM 节点的变动，在所有 DOM 变动完成后，执行回调函数。(若当前环境存在 Promise,优先使用Promise)
- setImmediate: 用于中断长时间运作的操作，并在浏览器完成其他操作(如事件和显示更新)后立即运行回调函数
- 如果以上条件都不行，则采用setTimeOut 把函数延迟到 DOM更新之后再使用，原因是宏任务消耗大于微任务，优先使用微任务，最后使用消耗最大的宏任务。


# computed 和 watch 的区别？
`computed` 是 `vue` 的计算属性，计算属性只在相关响应式依赖发生改变时才会重新求值。只要相关依赖不发生变化，多次访问该计算属性会立即返回之前的计算结果，而不需要重新求值，计算属性必须有 `return` 关键词。<br/>
`watch` 是 `vue` 的侦听器，根据侦听某一数据的变化而触发函数，限制执行该操作的频率，并在得到最终结果前，设置相应的中间状态。<br/>
计算属性一般用在模版渲染中，某个值依赖其他响应对象甚至计算属性而来；而侦听器属性适用于观测某个值的变化去完成一段复杂的业务逻辑。

-----

# v-if 与 v-show 的区别？
`v-if` 指令会确保在条件块内的事件监听器和子组件会适当的被销毁和重建。
`v-show` 指令的元素始终被保留在DOM中。只是简单的切换元素是否显示。
`v-if` 指令有更高的切换开销，而 `v-show` 指令有更高的初始渲染开销。因此。如果需要非常频繁的切换，则使用`v-show`指令；如果运行条件很少改变，则使用`v-if`。

-----

# v-if 和 v-for 为什么不推荐一起使用？
`vue2`中 `v-for` 的优先级大于 `v-if`, 这意味这`v-if` 分别重复运行于每一个 `v-for` 循环中。如果要遍历的数组很大，而真正要展示的数据很少时，将造成很大的性能浪费。
`vue3`中 `v-if`的优先级大于 `v-for` 的优先级，这意味着 `v-if` 指令将不能访问 `v-for`指令中的变量。

-----

# vue中key的作用？
`key` 的作用主要是 为了更高效的更新虚拟DOM。
`Vue` 判断两个节点是否相同时，主要根据两者`key` 和 元素类型`tag`。若不设置`key`,它的值就是`undefined`，则可能永远认为这是两个相同的节点，只能去做更新操作，将造成大量的DOM更新操作。

-----

# vue中的data为什么一定要是一个函数
在new Vue()中，可以是函数也可以是对象，因为根实例只有一个，不会产生数据污染。
在组件中，data必须为函数，是为了防止多个组件实例对象之间共用一个data,产生数据污染。采用函数的形式，initData时会将其作为工厂函数都会返回全新的。